#!/usr/bin/env python2
import os
import cv2
import yaml
from enum import Enum

import rospy
from cv_bridge import CvBridge, CvBridgeError
from sensor_msgs.msg import Image as ImageMsg, PointCloud2

from mcr_perception_msgs.srv import DetectImage, DetectImageRequest
from mas_perception_libs import ImageDetector
from mas_perception_libs.utils import case_insensitive_glob, cloud_msg_to_image_msg, crop_organized_cloud_msg
from mas_perception_libs.visualization import draw_labeled_boxes, draw_labeled_boxes_img_msg, bgr_dict_from_classes


class ImageSourceType(Enum):
    CLOUD_TOPIC = 0
    IMAGE_TOPIC = 1
    IMAGE_DIR = 2
    UNKNOWN = 3


def request_single_image_detection(detection_client, img_msg):
    # send request and get response
    request = DetectImageRequest()
    request.images.append(img_msg)
    response = detection_client(request)

    # draw boxes on original image
    # each detection is for one image message, show there should be exactly 1 detection
    if len(response.detections) == 0:
        rospy.logerr('no detection for requested image')
        return None

    return response.detections[0]


def handle_image_directory(image_dir, detection_client, result_pub, color_dict):
    # glob image files
    image_files = []
    for file_type in ('*.jpg', '*.jpeg', '*.png', '*.bmp'):
        image_files.extend(case_insensitive_glob(os.path.join(image_dir, file_type)))

    # send requests and publish results
    bridge = CvBridge()
    for image_path in image_files:
        # read and convert image to ROS message
        img = cv2.imread(image_path)
        try:
            img_msg = bridge.cv2_to_imgmsg(img, 'bgr8')
        except CvBridgeError as e:
            rospy.logerr('failed to convert input from OpenCV image to ROS message: ' + e.message)
            continue

        # send request and get response
        detection = request_single_image_detection(detection_client, img_msg)

        if detection is None:
            rospy.logerr('no detection for image: ' + image_path)
            continue

        boxes = ImageDetector.detection_msg_to_bounding_boxes(detection, color_dict)
        box_image = draw_labeled_boxes(img, boxes)

        # convert result to message and publish
        try:
            result_msg = bridge.cv2_to_imgmsg(box_image, 'bgr8')
        except CvBridgeError as e:
            rospy.logerr('failed to convert result from OpenCV image to ROS message: ' + e.message)
            continue

        result_pub.publish(result_msg)

        # sleep for 1 second
        rospy.sleep(1.0)


class TopicHandler(object):
    def __init__(self, detection_client, result_pub, color_dict):
        self._detection_client = detection_client
        self._result_pub = result_pub
        self._color_dict = color_dict
        self._cv_bridge = CvBridge()


class CloudTopicHandler(TopicHandler):
    def __init__(self, cloud_topic_name, detection_client, result_pub, color_dict):
        super(CloudTopicHandler, self).__init__(detection_client, result_pub, color_dict)
        self._cloud_sub = rospy.Subscriber(cloud_topic_name, PointCloud2, self._cloud_callback)
        self._cropped_pub = rospy.Publisher('~first_cropped_cloud', PointCloud2, queue_size=2)

    def _cloud_callback(self, cloud_msg):
        img_msg = cloud_msg_to_image_msg(cloud_msg)
        detection = request_single_image_detection(self._detection_client, img_msg)

        # generate 2D bounding boxes from detection result
        boxes = ImageDetector.detection_msg_to_bounding_boxes(detection, self._color_dict)
        if len(boxes) == 0:
            return

        # draw resulting image
        drawn_img_msg = draw_labeled_boxes_img_msg(self._cv_bridge, img_msg, boxes)
        self._result_pub.publish(drawn_img_msg)

        # crop point cloud
        cropped_cloud = crop_organized_cloud_msg(cloud_msg, boxes[0])
        self._cropped_pub.publish(cropped_cloud)


class ImageTopicHandler(TopicHandler):
    def __init__(self, image_topic_name, detection_client, result_pub, color_dict):
        super(ImageTopicHandler, self).__init__(detection_client, result_pub, color_dict)
        self._image_sub = rospy.Subscriber(image_topic_name, ImageMsg, self._image_callback)

    def _image_callback(self, image_msg):
        detection = request_single_image_detection(self._detection_client, image_msg)
        boxes = ImageDetector.detection_msg_to_bounding_boxes(detection, self._color_dict)
        drawn_img_msg = draw_labeled_boxes_img_msg(self._cv_bridge, image_msg, boxes)
        self._result_pub.publish(drawn_img_msg)


def main(image_soure_type, image_source, service_name, result_topic, class_annotation_file):
    rospy.loginfo('Image source: {0}: {1}'.format(image_soure_type, image_source))

    # wait for service to come up
    rospy.wait_for_service(service_name, timeout=5.0)
    try:
        detection_client = rospy.ServiceProxy(service_name, DetectImage)
    except rospy.ServiceException as e:
        rospy.logerr('failed to get proxy for service "{0}": {1}'.format(service_name, e.message))
        raise

    # create publisher for image result
    result_pub = rospy.Publisher(result_topic, ImageMsg, queue_size=1)

    # read classes and create color dictionary for them
    with open(class_annotation_file, 'r') as infile:
        classes = yaml.load(infile)
    color_dict = bgr_dict_from_classes(classes.values())

    # handle image directory case
    if image_soure_type == ImageSourceType.IMAGE_DIR:
        handle_image_directory(image_source, detection_client, result_pub, color_dict)
    elif image_soure_type == ImageSourceType.CLOUD_TOPIC:
        CloudTopicHandler(image_source, detection_client, result_pub, color_dict)
    elif image_soure_type == ImageSourceType.IMAGE_TOPIC:
        ImageTopicHandler(image_source, detection_client, result_pub, color_dict)
    else:
        raise ValueError('unhandled image source type: ' + str(image_soure_type))


if __name__ == '__main__':
    rospy.init_node('~image_detection_client_test')

    # get service name and result topic
    service_name = rospy.get_param('~service_name', '~detect_image')
    result_topic = rospy.get_param('~result_topic', '~result_image')

    img_source_type = ImageSourceType.UNKNOWN

    # read image directory
    image_source = rospy.get_param('~image_directory', None)
    if image_source:
        if os.path.exists(image_source):
            img_source_type = ImageSourceType.IMAGE_DIR
        else:
            rospy.logwarn('image directory does not exist: ' + image_source)

    if img_source_type == ImageSourceType.UNKNOWN:
        image_source = rospy.get_param('~cloud_topic', None)
        if image_source:
            img_source_type = ImageSourceType.CLOUD_TOPIC

    if img_source_type == ImageSourceType.UNKNOWN:
        image_source = rospy.get_param('~image_topic', None)
        if image_source:
            img_source_type = ImageSourceType.IMAGE_TOPIC

    if img_source_type == ImageSourceType.UNKNOWN:
        raise ValueError('no valid image source specified')

    # get parameters for detector class
    class_annotation_file = rospy.get_param('~class_annotations', None)
    if class_annotation_file is None:
        raise ValueError('"~class_annotations" not specified')
    if not os.path.exists(class_annotation_file):
        raise ValueError('"~class_annotations" file does not exist: ' + class_annotation_file)

    # test detection server
    main(img_source_type, image_source, service_name, result_topic, class_annotation_file)

    rospy.spin()
